### 分离development和production



在前面说过在打包时分为<font style="color:#f03d3d">development</font>和<font style="color:#f03d3d">production</font>模式，对应了本地开发和线上发布。两种模式打包代码需要具有一定的差异性。所以最好将两种配置进行分离，以进行区分。

在前面说过，不同模式使用不同命令。每条指令可以指向一个webpack配置文件。那其实就表明只要不同命令编写使用不同的webpack配置文件就可以进行区分。

<img src=".//images//image-06-01.png" width="400">

<img src=".//images//image-06-02.png" width="400">

然后在不同的webpack配置文件中使用指定的配置属性即可。

> :whale2:
>
> 将webpack配置文件放入一个指定的目录，方便其管理，
>
> webpack配置文件名称可以自定义。**webpack.config.js**只是一个默认的名称，当使用 **--config**属性 指向特定文件名称时，可以设置为任意名称



在不同webpack配置文件中设置不同的配置

***webpack.dev.js***

```js
const path = require('path')
const webpack = require("webpack");
const HtmlWebpackPlugin = require('html-webpack-plugin');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');

const modules = {

  mode:'development',
  //  因为文件地址不再是根目录，所以需要加上 ../
  entry: path.join(__dirname,'../src/index.js') ,
 // dev不需要缓存js
  output: {
    path: path.join(__dirname,'../dist'),
    filename: '[name].js'
  },

  module:{
    rules:[
      {
        //  所有的.js文件都走babel-loader
        test:/\.js(x?)$/,
        include:path.join(__dirname,'../src'),
        loader: "babel-loader"
      }
    ]
  },

//  dev不需要压缩
  optimization: {
    minimize: false,
  },

  plugins: [
    new HtmlWebpackPlugin({
      //  template的title优先级大于当前数据
      title: 'my-cli',
      //  文件名称
      filename: 'index.html',

      //  模板路径
      template: path.join(__dirname, '../src/index.html'),
      // 用于打包后引用脚本时的路径
      publicPath: './',

      //  是否将打包的资源引用到当前HTML， false代表不引用
      //  true或者body将打包后的js脚本放入body元素下，head则将脚本放到中
      //  默认为true
      inject: 'body',
      //  加载js方式，值为defer/blocking
      //  默认为blocking, 如果设置了defer，则在js引用标签上加上此属性，进行异步加载
      scriptLoading: 'blocking',

      //  是否进行缓存，默认为true，在开发环境可以设置成false
      cache: false,
      //  添加mate属性
      meta: {}
    }),

    new CleanWebpackPlugin({

      //  假装文件删除
      //  如果为false则代表真实删除，如果为true，则代表不删除
      dry: false,
      //  是否打印日志到控制台 默认为false
      verbose: true,
      cleanStaleWebpackAssets: false,
      //  允许保留本次打包的文件
      //  true为允许，false为不允许，保留本次打包结果，也就是会删除本次打包的文件
      //  默认为true
      protectWebpackAssets: true,
      //  每次打包之前删除匹配的文件
      cleanOnceBeforeBuildPatterns: ['**/*'],

      //  每次打包之后删除匹配的文件
    }),
    new webpack.DefinePlugin({ "global_a": JSON.stringify("我是一个打包配置的全局变量") }),
  ],

  resolve: {
    alias:{
      //  设置路径别名
      '@': path.join(__dirname,'../src'),

      '~': path.join(__dirname, '../src/assets')
    },
    //  可互忽略的后缀
    extensions:['.jsx', '.js', '.json', '.css'],
    //  默认读取的文件名
    mainFiles:['index', 'main'],
  }
}

//  使用node。js的导出，将配置进行导出
module.exports = modules
```



***webpack.pro.js***

```js
const path = require('path')
const webpack = require("webpack");
const HtmlWebpackPlugin = require('html-webpack-plugin')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const TerserPlugin = require('terser-webpack-plugin')

const modules = {

  mode: 'production',

  //  因为文件地址不再是根目录，所以需要加上 ../
  entry: path.join(__dirname,'../src/index.js') ,

  // prod需要缓存js
  output: {
    path: path.join(__dirname,'../dist'),
    filename: '[name]_[contenthash].js'
  },

  module:{
    rules:[
      {
        //  所有的.js文件都走babel-loader
        test:/\.js(x?)$/,
        include:path.join(__dirname,'../src'),
        loader: "babel-loader"
      }
    ]
  },


  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        //  包含哪些文件
        include:  /\.js(\?.*)?$/i,
        // //  排除哪些文件
        // exclude:/\.js(\?.*)?$/i,
        //  多进程并行运行，默认为true，开启，默认并发数量为os.cpus()-1
        //  可以设置为false(不使用多线程)或者数值（并发数量）
        parallel:true,

        //  可以设置一个function，使用其它压缩插件覆盖默认的压缩插件，默认为undefined，
        minify:undefined,

        terserOptions: {
          // //  是否防止篡改函数名称，true代表防止篡改，即保留函数名称，false即可以篡改，
          // //  此属性对使用Function.prototype.name
          // //  默认为false
          keep_fnames:false,
          // //  是否防止篡改类名称
          keep_classnames:false,
          // //  设置一些其它的解析
          parse: {},
          //  最小化es6模块。默认为false
          module:true,
          //  ·压缩配置

          //  format和output是同一个属性值，，名称不一致，output不建议使用了，被放弃
          format: {
            comments:false,
          },
          //  是否支持IE8，默认不支持
          ie8:false,
          compress: {
            // 是否使用默认设置，这个属性当只启用指定某些选项时可以设置为false
            defaults:false,
            //  是否移除无法访问的代码
            dead_code:false,

            // 折叠仅仅使用一次的变量
            collapse_vars:true,
            warnings:true,
            //  是否删除所有 console.*语句，默认为false，这个可以在线上设置为true
            //  是否删除所有debugger语句，默认为true
            drop_debugger:true,
            //  移除指定func，这个属性假定函数没有任何副作用，可以使用此属性移除所有指定func
            // pure_funcs: ['console.log'], //移除console
          },
        },
        //  是否将注释提出到单独的文件中
        //  值Boolean|String|RegExp|Function<(node, comment) -> Boolean|Object>|Object
        //  默认为true， 只提取/^\**!|@preserve|@license|@cc_on/i注释
        //  感觉没什么特殊情况直接设置为false即可
        extractComments:false,
      })
    ]
  },

  plugins: [
    new HtmlWebpackPlugin({
      //  template的title优先级大于当前数据
      title: 'my-cli',
      //  文件名称
      filename: 'index.html',

      //  模板路径
      template: path.join(__dirname, '../src/index.html'),
      // 用于打包后引用脚本时的路径
      publicPath: './',

      //  是否将打包的资源引用到当前HTML， false代表不引用
      //  true或者body将打包后的js脚本放入body元素下，head则将脚本放到中
      //  默认为true
      inject: 'body',
      //  加载js方式，值为defer/blocking
      //  默认为blocking, 如果设置了defer，则在js引用标签上加上此属性，进行异步加载
      scriptLoading: 'blocking',

      //  是否进行缓存，默认为true，在开发环境可以设置成false
      cache: false,
      //  添加mate属性
      meta: {}
    }),

    new CleanWebpackPlugin({

      //  假装文件删除
      //  如果为false则代表真实删除，如果为true，则代表不删除
      dry: false,
      //  是否打印日志到控制台 默认为false
      verbose: true,
      cleanStaleWebpackAssets: false,
      //  允许保留本次打包的文件
      //  true为允许，false为不允许，保留本次打包结果，也就是会删除本次打包的文件
      //  默认为true
      protectWebpackAssets: true,
      //  每次打包之前删除匹配的文件
      cleanOnceBeforeBuildPatterns: ['**/*'],

      //  每次打包之后删除匹配的文件
   
    new webpack.DefinePlugin({ "global_a": JSON.stringify("我是一个打包配置的全局变量") }),
  ],

  resolve: {
    alias:{
      //  设置路径别名
      '@':path.join(__dirname,'../src'),

      '~': path.join(__dirname, '../src/assets')
    },
    //  可互忽略的后缀
    extensions:['.jsx', '.js', '.json', '.css'],
    //  默认读取的文件名
    mainFiles:['index', 'main'],
  }
}

//  使用node。js的导出，将配置进行导出
module.exports = modules
```



#### webpack-merge

上面对两个配置文件是对**webpack.config.js**文件进行拆分为两种打包模式的配置文件。基本上就是将原来的**webpack.config.js**代码复制，然后删除其不用的代码。但是可以看到即便是不同模式下的打包，也会具有很多相同的配置，编写配置时不可能去编写两次。那么就需要抽出相同配置，然后使用这两个配置对象去加载公共配置。

一个简单的抽出，然后合并，完全可以使用**Object.assign**去完成，不过因为内部属性的繁多，写起来也是一个比较麻烦的事。所以，社区内就有人提供了合并webpack配置的库，可以直接进行使用，这个库就是 [webpack-merge](https://github.com/survivejs/webpack-merge)

> yarn add -D webpack-merge@5.7.3



这个库很简单，只是提供一个函数将传入的对象进行合并，

> :whale2:webpack配置本质是一个JS对象，所以合并其实只是处理JS对象。



先来将公共代码进行抽出， 抽到一个*webpack.common.js*的文件中，以方便管理