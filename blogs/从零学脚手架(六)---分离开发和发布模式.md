### 分离development和production



在前面说过在打包时分为<font style="color:#f03d3d">development</font>和<font style="color:#f03d3d">production</font>模式，两种模式分别**约定**了 本地开发打包 和 线上发布。

一般都是使用不同命令去执行不同打包操作，在前面虽然也进行了分离，但依然使用的一个配置文件，并没有做到彻底分离。

在前面也提过，分离两种模式最好是使用两个配置文件，打包命令使用 **--config** 参数指定具体的文件名称

<img src=".//images//image-06-01.png" width="400">



<img src=".//images//image-06-02.png" width="400">

> :whale2:
>
> 将webpack配置文件放入一个指定的目录，方便其管理，
>
> webpack配置文件名称可以自定义。**webpack.config.js**只是一个默认的名称，当使用 **--config**属性 指向特定文件名称时，可以设置为任意名称



**config.js**便是前面控制路径的对象，在此抽出文件进行管理

```js
const path = require('path')

module.exports.config = {
  root: path.join(__dirname, '../'),
}

```

因为**config.js**文件在*build*目录下，所以root属性则改为上级目录







然后在两个配置文件中设置各自的需要的配置项即可

***webpack.dev.js***

```js
const path = require('path')
const webpack = require("webpack");
const HtmlWebpackPlugin = require('html-webpack-plugin');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
//	引用config对象，因导出时为 module.exports.config 所以在此使用 { config }导入
const { config }  = require('./config');

const modules = {

  mode:'development',
    
  entry: path.join(config.root, 'src/index.js') ,
  // dev不需要缓存js
  output: {
    path: path.join(config.root, 'dist') ,
    filename: '[name].js'
  },

  module:{
    rules:[
      {
        //  所有的.js文件都走babel-loader
        test:/\.js(x?)$/,
        include: path.join(config.root, 'src'),
        loader: "babel-loader"
      }
    ]
  },

//  dev不需要压缩
  optimization: {
    minimize: false,
  },

  plugins: [
    new HtmlWebpackPlugin({
      //  template的title优先级大于当前数据
      title: 'my-cli',
      //  文件名称
      filename: 'index.html',

      //  模板路径
      template: path.join(config.root, 'src/index.html'),
      // 用于打包后引用脚本时的路径
      publicPath: './',

      //  是否将打包的资源引用到当前HTML， false代表不引用
      //  true或者body将打包后的js脚本放入body元素下，head则将脚本放到中
      //  默认为true
      inject: 'body',
      //  加载js方式，值为defer/blocking
      //  默认为blocking, 如果设置了defer，则在js引用标签上加上此属性，进行异步加载
      scriptLoading: 'blocking',

      //  是否进行缓存，默认为true，在开发环境可以设置成false
      cache: false,
      //  添加mate属性
      meta: {}
    }),

    new CleanWebpackPlugin({

      //  假装文件删除
      //  如果为false则代表真实删除，如果为true，则代表不删除
      dry: false,
      //  是否打印日志到控制台 默认为false
      verbose: true,
      cleanStaleWebpackAssets: false,
      //  允许保留本次打包的文件
      //  true为允许，false为不允许，保留本次打包结果，也就是会删除本次打包的文件
      //  默认为true
      protectWebpackAssets: true,
      //  每次打包之前删除匹配的文件
      cleanOnceBeforeBuildPatterns: ['**/*'],

      //  每次打包之后删除匹配的文件
    }),
    new webpack.DefinePlugin({ "global_a": JSON.stringify("我是一个打包配置的全局变量") }),
  ],

  resolve: {
    alias:{
      //  设置路径别名
      '@': path.join(config.root, 'src'),

      '~': path.join(config.root, 'src/assets'),
    },
    //  可互忽略的后缀
    extensions:['.jsx', '.js', '.json', '.css'],
    //  默认读取的文件名
    mainFiles:['index', 'main'],
  }
}

//  使用node。js的导出，将配置进行导出
module.exports = modules
```



***webpack.pro.js***

```js
const path = require('path')
const webpack = require("webpack");
const HtmlWebpackPlugin = require('html-webpack-plugin')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const TerserPlugin = require('terser-webpack-plugin')
//	引用config对象，因导出时为 module.exports.config 所以在此使用 { config }导入
const { config }  = require('./config');

const modules = {

  mode: 'production',

  entry: path.join(config.root, 'src/index.js'),

  // prod需要缓存js
  output: {
    path: path.join(config.root, 'dist') ,
    filename: '[name]_[contenthash].js'
  },

  module:{
    rules:[
      {
        //  所有的.js文件都走babel-loader
        test:/\.js(x?)$/,
        include: path.join(config.root, 'src') ,
        loader: "babel-loader"
      }
    ]
  },


  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        //  包含哪些文件
        include:  /\.js(\?.*)?$/i,
        // //  排除哪些文件
        // exclude:/\.js(\?.*)?$/i,
        //  多进程并行运行，默认为true，开启，默认并发数量为os.cpus()-1
        //  可以设置为false(不使用多线程)或者数值（并发数量）
        parallel:true,

        //  可以设置一个function，使用其它压缩插件覆盖默认的压缩插件，默认为undefined，
        minify:undefined,

        terserOptions: {
          // //  是否防止篡改函数名称，true代表防止篡改，即保留函数名称，false即可以篡改，
          // //  此属性对使用Function.prototype.name
          // //  默认为false
          keep_fnames:false,
          // //  是否防止篡改类名称
          keep_classnames:false,
          // //  设置一些其它的解析
          parse: {},
          //  最小化es6模块。默认为false
          module:true,
          //  ·压缩配置

          //  format和output是同一个属性值，，名称不一致，output不建议使用了，被放弃
          format: {
            comments:false,
          },
          //  是否支持IE8，默认不支持
          ie8:false,
          compress: {
            // 是否使用默认设置，这个属性当只启用指定某些选项时可以设置为false
            defaults:false,
            //  是否移除无法访问的代码
            dead_code:false,

            // 折叠仅仅使用一次的变量
            collapse_vars:true,
            warnings:true,
            //  是否删除所有 console.*语句，默认为false，这个可以在线上设置为true
            //  是否删除所有debugger语句，默认为true
            drop_debugger:true,
            //  移除指定func，这个属性假定函数没有任何副作用，可以使用此属性移除所有指定func
            // pure_funcs: ['console.log'], //移除console
          },
        },
        //  是否将注释提出到单独的文件中
        //  值Boolean|String|RegExp|Function<(node, comment) -> Boolean|Object>|Object
        //  默认为true， 只提取/^\**!|@preserve|@license|@cc_on/i注释
        //  感觉没什么特殊情况直接设置为false即可
        extractComments:false,
      })
    ]
  },

  plugins: [
    new HtmlWebpackPlugin({
      //  template的title优先级大于当前数据
      title: 'my-cli',
      //  文件名称
      filename: 'index.html',

      //  模板路径
      template:path.join(config.root, 'src/index.html') ,
      // 用于打包后引用脚本时的路径
      publicPath: './',

      //  是否将打包的资源引用到当前HTML， false代表不引用
      //  true或者body将打包后的js脚本放入body元素下，head则将脚本放到中
      //  默认为true
      inject: 'body',
      //  加载js方式，值为defer/blocking
      //  默认为blocking, 如果设置了defer，则在js引用标签上加上此属性，进行异步加载
      scriptLoading: 'blocking',

      //  是否进行缓存，默认为true，在开发环境可以设置成false
      cache: false,
      //  添加mate属性
      meta: {}
    }),

    new CleanWebpackPlugin({

      //  假装文件删除
      //  如果为false则代表真实删除，如果为true，则代表不删除
      dry: false,
      //  是否打印日志到控制台 默认为false
      verbose: true,
      cleanStaleWebpackAssets: false,
      //  允许保留本次打包的文件
      //  true为允许，false为不允许，保留本次打包结果，也就是会删除本次打包的文件
      //  默认为true
      protectWebpackAssets: true,
      //  每次打包之前删除匹配的文件
      cleanOnceBeforeBuildPatterns: ['**/*'],

      //  每次打包之后删除匹配的文件
    }),

    new webpack.DefinePlugin({ "global_a": JSON.stringify("我是一个打包配置的全局变量") }),
  ],

  resolve: {
    alias:{
      //  设置路径别名
      '@': path.join(config.root, 'src'),

      '~': path.join(config.root, 'src/assets')
    },
    //  可互忽略的后缀
    extensions:['.jsx', '.js', '.json', '.css'],
    //  默认读取的文件名
    mainFiles:['index', 'main'],
  }
}

//  使用node。js的导出，将配置进行导出
module.exports = modules
```



> :whale2::whale2:  在前面说过**context**属性默认为项目根目录，所以如果使用相对路径，就算改变了webpack配置文件路径，使用 
>
> ```js
> entry: './src/index.js',
> ```
>
> 依然可以运行，就是个人感觉这样看起来有些奇怪。所以不太喜欢这样使用



> :whale2: 路径由于自己控制，所以在改变webpack文件目录时基本不需要改动，只要改动根目录即可。



#### webpack-merge

在上面两个文件中可以发现具有好多共同的配置，而在开发中不可能写两份代码。

一般解决这种情况的方案 就是抽离出一个公共配置对象（common），然后开发配置（dev）和发布配置（pro）中将公共配置（common）合并（merge）。

webpack社区中提供了一个<font style="color:#f03d3d">webpack-merge</font>库，这个库是将多个webpack配置对象进行合并。本质类似于**Object.assign**，只是功能稍微强一些吧了。

> yarn add -D webpack-merge@5.7.3



> :whale2:webpack配置本质是一个JS对象，所以合并（merge）其实只是处理JS对象。



先将公共代码进行抽出， 抽到一个*webpack.common.js*的文件中。

```js
const path = require('path')
const webpack = require("webpack");
const HtmlWebpackPlugin = require('html-webpack-plugin')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const TerserPlugin = require('terser-webpack-plugin')
//	引用config对象，因导出时为 module.exports.config 所以在此使用 { config }导入
const { config }  = require('./config');

//  isDev  boolean

//  使用node。js的导出，将配置进行导出
module.exports =  (isDev) => {
//  当前模式是否为dev模式，使用此属性来做一个简单显示判断
  isDev = isDev === undefined ? true : isDev;

  return {

    entry: path.join(config.root, 'src/index.js'),
    // 根据isDev参数判断是否缓存JS
    output: {
      //  出口文件的目录地址
      path: path.join(config.root, 'dist'),
      //  出口文件名称，contenthash代表一种缓存，只有文件更改才会更新hash值，重新打包
      filename: `[name]${isDev ? '' : '_[contenthash]'}.js`,
    },

    //devtool:false, //'eval'

    module: {
      rules: [
        {
          //  所有的.js文件都走babel-loader
          test: /\.js(x?)$/,
          include: path.join(config.root, 'src'),
          loader: "babel-loader"
        }
      ]
    },

    optimization: {
      // 根据当前模式进行判断是否需要压缩
      minimize: !isDev,
      minimizer: [
        new TerserPlugin({
          //  包含哪些文件
          include: /\.js(\?.*)?$/i,
          // //  排除哪些文件
          // exclude:/\.js(\?.*)?$/i,
          //  多进程并行运行，默认为true，开启，默认并发数量为os.cpus()-1
          //  可以设置为false(不使用多线程)或者数值（并发数量）
          parallel: true,

          //  可以设置一个function，使用其它压缩插件覆盖默认的压缩插件，默认为undefined，
          minify: undefined,

          terserOptions: {
            // //  是否防止篡改函数名称，true代表防止篡改，即保留函数名称，false即可以篡改，
            // //  此属性对使用Function.prototype.name
            // //  默认为false
            keep_fnames: false,
            // //  是否防止篡改类名称
            keep_classnames: false,
            // //  设置一些其它的解析
            parse: {},
            //  最小化es6模块。默认为false
            module: true,
            //  ·压缩配置

            //  format和output是同一个属性值，，名称不一致，output不建议使用了，被放弃
            format: {
              comments: false,
            },
            //  是否支持IE8，默认不支持
            ie8: false,
            compress: {
              // 是否使用默认设置，这个属性当只启用指定某些选项时可以设置为false
              defaults: false,
              //  是否移除无法访问的代码
              dead_code: false,

              // 折叠仅仅使用一次的变量
              collapse_vars: true,
              warnings: true,
              //  是否删除所有 console.*语句，默认为false，这个可以在线上设置为true
              //  是否删除所有debugger语句，默认为true
              drop_debugger: true,
              //  移除指定func，这个属性假定函数没有任何副作用，可以使用此属性移除所有指定func
              // pure_funcs: ['console.log'], //移除console
            },
          },
          //  是否将注释提出到单独的文件中
          //  值Boolean|String|RegExp|Function<(node, comment) -> Boolean|Object>|Object
          //  默认为true， 只提取/^\**!|@preserve|@license|@cc_on/i注释
          //  感觉没什么特殊情况直接设置为false即可
          extractComments: false,
        })
      ]
    },

    plugins: [
      new HtmlWebpackPlugin({
        //  template的title优先级大于当前数据
        title: 'my-cli',
        //  文件名称
        filename: 'index.html',

        //  模板路径
        template: path.join(config.root, 'src/index.html'),
        // 用于打包后引用脚本时的路径
        publicPath: './',

        //  是否将打包的资源引用到当前HTML， false代表不引用
        //  true或者body将打包后的js脚本放入body元素下，head则将脚本放到中
        //  默认为true
        inject: 'body',
        //  加载js方式，值为defer/blocking
        //  默认为blocking, 如果设置了defer，则在js引用标签上加上此属性，进行异步加载
        scriptLoading: 'blocking',

        //  是否进行缓存，默认为true，在开发环境可以设置成false
        cache: false,
        //  添加mate属性
        meta: {}
      }),

      new CleanWebpackPlugin({

        //  假装文件删除
        //  如果为false则代表真实删除，如果为true，则代表不删除
        dry: false,
        //  是否打印日志到控制台 默认为false
        verbose: true,
        cleanStaleWebpackAssets: false,
        //  允许保留本次打包的文件
        //  true为允许，false为不允许，保留本次打包结果，也就是会删除本次打包的文件
        //  默认为true
        protectWebpackAssets: true,
        //  每次打包之前删除匹配的文件
        cleanOnceBeforeBuildPatterns: ['**/*'],

        //  每次打包之后删除匹配的文件
      }),

      new webpack.DefinePlugin({ "global_a": JSON.stringify("我是一个打包配置的全局变量") }),
    ],

    resolve: {
      alias: {
        //  设置路径别名
        '@': path.join(config.root, 'src'),

        '~': path.join(config.root, 'src/assets'),
      },
      //  可互忽略的后缀
      extensions: ['.jsx', '.js', '.json', '.css'],
      //  默认读取的文件名
      mainFiles: ['index', 'main'],
    }
  }
}
```



在上面代码中*webpack.common.js* 导出的是一个函数形式，函数参数是一个*是否为dev的bool类型*，这样做是可以将一些微小的差异化做到在**common**中区分。例如，

1. output中的filename 。 dev不需要缓存，pro需要缓存
2. optimization   开关使用isDev进行控制。



> :whale2:具体怎么操作根据不同人习惯导致稍有差异，但是差异也不过为编码习惯问题，最后抛出的都是webpack提供的规则。



现在，就可以在 *webpack.dev.js* 和 *webpack.pro.js* 文件中使用<font style="color:#f03d3d">webpack-merge</font>进行 合并 *webpack.common.js* 模块

**webpack.dev.js**

```js
const { merge } = require('webpack-merge');
const common = require('./webpack.common');
//  使用node。js的导出，将配置进行导出
module.exports = merge([
  common(true),
  {
    mode:'development',
  }
])

```



**webpack.pro.js**

```js
const { merge } = require('webpack-merge');
const common = require('./webpack.common');
//  使用node。js的导出，将配置进行导出
module.exports = merge([
  common(false),
  {
    mode:'production',
  }
])

```



可以看到 代码中直接调用了<font style="color:#f03d3d">webpack-merge</font>提供的一个***merge***函数，然后到导出。***merge***函数会将传入的多个对象进行合并，然后返回合并后的对象。其形式与**Object.assign** 一样。

> :whale2: ***merge***函数参数可以使用数组，或可变参数传递。



### 总结

> :whale2::whale2::whale2:
>
> 1. 开发、发布代码分离主要是为了管理代码，并不是强制性的，具体结构也是依照每个人编码习惯
> 2. **webpack-merge**只是将多个对象进行合并的库，与**Object.assign**一样，只不过更为强大吧了。而webpack配置本质是一个JS对象。



### 本文参考

*  [webpack-merge](https://www.npmjs.com/package/webpack-merge)



### 本文依赖

* [webpack-merge@5.7.3](https://www.npmjs.com/package/webpack-merge/v/5.7.3)



### package.json

```js
{
  "name": "my-cli",
  "version": "1.0.0",
  "main": "index.js",
  "author": "mowenjinzhao<yanzhangshuai@126.com>",
  "license": "MIT",
  "devDependencies": {
    "@babel/core": "7.12.10",
    "@babel/plugin-transform-runtime": "7.12.10",
    "@babel/preset-env": "7.12.11",
    "@babel/preset-react": "7.12.10",
    "@babel/runtime-corejs3": "7.12.5",
    "babel-loader": "8.2.2",
    "clean-webpack-plugin": "3.0.0",
    "html-webpack-plugin": "4.5.0",
    "terser-webpack-plugin": "5.0.3",
    "webpack": "5.14.0",
    "webpack-cli": "4.4.0",
    "webpack-merge": "5.7.3"
  },
  "dependencies": {
    "core-js": "3.8.1",
    "react": "17.0.1",
    "react-dom": "^17.0.1",
    "regenerator-runtime": "0.13.7"
  },
  "scripts": {
    "start": "webpack-dev-server  --config build/webpack.dev.js",
    "build": "webpack  --config build/webpack.pro.js",
  },
  "browserslist": [
    "ie 9",
    "Chrome > 75"
  ]
}

```



### webpack.common.js

```js
const path = require('path')
const webpack = require("webpack");
const HtmlWebpackPlugin = require('html-webpack-plugin')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const TerserPlugin = require('terser-webpack-plugin')
//	引用config对象，因导出时为 module.exports.config 所以在此使用 { config }导入
const { config }  = require('./config');

//  isDev  boolean

//  使用node。js的导出，将配置进行导出
module.exports =  (isDev) => {
//  当前模式是否为dev模式，使用此属性来做一个简单显示判断
  isDev = isDev === undefined ? true : isDev;

  return {

    entry: path.join(config.root, 'src/index.js'),
    // 根据isDev参数判断是否缓存JS
    output: {
      //  出口文件的目录地址
      path: path.join(config.root, 'dist'),
      //  出口文件名称，contenthash代表一种缓存，只有文件更改才会更新hash值，重新打包
      filename: `[name]${isDev ? '' : '_[contenthash]'}.js`,
    },

    //devtool:false, //'eval'

    module: {
      rules: [
        {
          //  所有的.js文件都走babel-loader
          test: /\.js(x?)$/,
          include: path.join(config.root, 'src'),
          loader: "babel-loader"
        }
      ]
    },

    optimization: {
      // 根据当前模式进行判断是否需要压缩
      minimize: !isDev,
      minimizer: [
        new TerserPlugin({
          //  包含哪些文件
          include: /\.js(\?.*)?$/i,
          // //  排除哪些文件
          // exclude:/\.js(\?.*)?$/i,
          //  多进程并行运行，默认为true，开启，默认并发数量为os.cpus()-1
          //  可以设置为false(不使用多线程)或者数值（并发数量）
          parallel: true,

          //  可以设置一个function，使用其它压缩插件覆盖默认的压缩插件，默认为undefined，
          minify: undefined,

          terserOptions: {
            // //  是否防止篡改函数名称，true代表防止篡改，即保留函数名称，false即可以篡改，
            // //  此属性对使用Function.prototype.name
            // //  默认为false
            keep_fnames: false,
            // //  是否防止篡改类名称
            keep_classnames: false,
            // //  设置一些其它的解析
            parse: {},
            //  最小化es6模块。默认为false
            module: true,
            //  ·压缩配置

            //  format和output是同一个属性值，，名称不一致，output不建议使用了，被放弃
            format: {
              comments: false,
            },
            //  是否支持IE8，默认不支持
            ie8: false,
            compress: {
              // 是否使用默认设置，这个属性当只启用指定某些选项时可以设置为false
              defaults: false,
              //  是否移除无法访问的代码
              dead_code: false,

              // 折叠仅仅使用一次的变量
              collapse_vars: true,
              warnings: true,
              //  是否删除所有 console.*语句，默认为false，这个可以在线上设置为true
              //  是否删除所有debugger语句，默认为true
              drop_debugger: true,
              //  移除指定func，这个属性假定函数没有任何副作用，可以使用此属性移除所有指定func
              // pure_funcs: ['console.log'], //移除console
            },
          },
          //  是否将注释提出到单独的文件中
          //  值Boolean|String|RegExp|Function<(node, comment) -> Boolean|Object>|Object
          //  默认为true， 只提取/^\**!|@preserve|@license|@cc_on/i注释
          //  感觉没什么特殊情况直接设置为false即可
          extractComments: false,
        })
      ]
    },

    plugins: [
      new HtmlWebpackPlugin({
        //  template的title优先级大于当前数据
        title: 'my-cli',
        //  文件名称
        filename: 'index.html',

        //  模板路径
        template: path.join(config.root, 'src/index.html'),
        // 用于打包后引用脚本时的路径
        publicPath: './',

        //  是否将打包的资源引用到当前HTML， false代表不引用
        //  true或者body将打包后的js脚本放入body元素下，head则将脚本放到中
        //  默认为true
        inject: 'body',
        //  加载js方式，值为defer/blocking
        //  默认为blocking, 如果设置了defer，则在js引用标签上加上此属性，进行异步加载
        scriptLoading: 'blocking',

        //  是否进行缓存，默认为true，在开发环境可以设置成false
        cache: false,
        //  添加mate属性
        meta: {}
      }),

      new CleanWebpackPlugin({

        //  假装文件删除
        //  如果为false则代表真实删除，如果为true，则代表不删除
        dry: false,
        //  是否打印日志到控制台 默认为false
        verbose: true,
        cleanStaleWebpackAssets: false,
        //  允许保留本次打包的文件
        //  true为允许，false为不允许，保留本次打包结果，也就是会删除本次打包的文件
        //  默认为true
        protectWebpackAssets: true,
        //  每次打包之前删除匹配的文件
        cleanOnceBeforeBuildPatterns: ['**/*'],

        //  每次打包之后删除匹配的文件
      }),

      new webpack.DefinePlugin({ "global_a": JSON.stringify("我是一个打包配置的全局变量") }),
    ],

    resolve: {
      alias: {
        //  设置路径别名
        '@': path.join(config.root, 'src'),

        '~': path.join(config.root, 'src/assets'),
      },
      //  可互忽略的后缀
      extensions: ['.jsx', '.js', '.json', '.css'],
      //  默认读取的文件名
      mainFiles: ['index', 'main'],
    }
  }
}

```



### webpack.dev.js

```js
const webpack = require('webpack');
const { merge } = require('webpack-merge');
const common = require('./webpack.common');
//  使用node。js的导出，将配置进行导出
module.exports = merge([
  common(true),
  {
    mode: 'development'
  }
])

```



### webpack.pro.js

```js
const { merge } = require('webpack-merge');
const common = require('./webpack.common');
//  使用node。js的导出，将配置进行导出
module.exports = merge([
  common(false),
  {
    mode:'production',
  }
])

```



